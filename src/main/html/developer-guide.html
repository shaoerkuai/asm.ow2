<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1.0">
  <title>ASM - Developer Guide</title>
  <link rel="stylesheet" type="text/css" href="style.css">
  <style>
    .page-content ol { list-style-type: none; }
    .page-content>ol { counter-reset: level1; }
    .page-content>ol li ol { counter-reset: level2; }
    .page-content>ol li ol li ol { counter-reset: level3; }
    .page-content>ol li:before {
      content: counter(level1);
      counter-increment: level1;
    }
    .page-content>ol li ol li:before {
      content: counter(level1) "." counter(level2);
      counter-increment: level2;
    }
    .page-content>ol li ol li ol li:before {
      content: counter(level1) "." counter(level2) "." counter(level3);
      counter-increment: level3;
    }
    .image {
      display: inline-block;
      text-align: center;
    }
    table { 
      width: 90%;
      margin: 0 auto 1em auto;
      background-color: #fafafa;
      border-spacing: 0; 
    }
    th {
      background-color: #eaeaea; 
      text-align: left; 
    }
    .jumpencoding td:nth-child(3) { width: 100%; }
    td, th { padding: 1px 8px; }
    .red { color: #f00; }
    .grey { color: #ddd; }
  </style>
</head>
<body>
  <!--header-->
  <div class="page-content">
    <h1>ASM 6 Developer Guide</h1>
    <p>by Eric Bruneton (last update 04/05/2018)</p>
    <ol>
      <li>
        <a href="#introduction">Introduction</a>
      </li>
      <li>
        <a href="#installation">Installation</a>
        <ol>
          <li>
            <a href="#overview">Overview</a>
          </li>
          <li>
            <a href="#building">Building</a>
          </li>
          <li>
            <a href="#tests">Running tests</a>
          </li>
          <li>
            <a href="#distribution">Creating a distribution</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#code">Code review</a>
        <ol>
          <li>
            <a href="#organization">Code organization</a>
          </li>
          <li>
            <a href="#structures">Main data structures</a>
            <ol>
              <li>
                <a href="#objectmodel">Object model</a>
              </li>
              <li>
                <a href="#collections">Collections</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#algorithms">Main algorithms</a>
            <ol>
              <li>
                <a href="#classreader">ClassReader</a>
              </li>
              <li>
                <a href="#classwriter">ClassWriter,
                AnnotationWriter, FieldWriter, MethodWriter and
                ModuleWriter</a>
              </li>
              <li>
                <a href="#label">Label</a>
              </li>
              <li>
                <a href="#toByteArray">toByteArray</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#jumpencoding">Jump instruction encoding
            algorithm</a>
            <ol>
              <li>
                <a href="#jumpencodingbasic">Basic algorithm</a>
              </li>
              <li>
                <a href="#jumpencodingimpact">Impact on stack map
                frames</a>
              </li>
              <li>
                <a href="#jumpencodingexample">An example</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#controlflow">Control and data flow analysis
            algorithm</a>
            <ol>
              <li>
                <a href="#fixpoint">Basic data flow analysis
                algorithm</a>
              </li>
              <li>
                <a href="#uninitializedtypes">Uninitialized
                types</a>
              </li>
              <li>
                <a href="#exceptionhandlers">Exception handlers</a>
              </li>
              <li>
                <a href="#deadcode">Dead code</a>
              </li>
              <li>
                <a href="#subroutines">Subroutines</a>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        <a href="#optimizations">Code optimizations</a>
        <ol>
          <li>
            <a href="#optimizeperformance">Optimizing
            performance</a>
          </li>
          <li>
            <a href="#optimizesize">Optimizing code size</a>
          </li>
          <li>
            <a href="#optimizeexample">An example</a>
          </li>
        </ol>
      </li>
    </ol>
    <h2 id="introduction">1 Introduction</h2>
    <p>This guide is primarily intended for ASM users that would
    like to contribute to the ASM code base, although it can be of
    interest for other users as well. It explains the organization
    of the code, the main data structures and the most complex
    algorithms. It also explains the strategies that have been used
    to optimize ASM performances as well as to minimize its code
    size, and illustrates this through a concrete example.</p>
    <h2 id="installation">2 Installation</h2>
    <p>This section explains how to compile the ASM source code,
    how to test it, and how to build a distribution, which is the
    first thing to know before contributing to this project. It
    assumes you have already downloaded the ASM source code, which
    can be done with <code>git clone
    https://gitlab.ow2.org/asm/asm.git</code>, or by downloading a
    snapshot of the git repository from <a href=
    "https://gitlab.ow2.org/asm/asm">https://gitlab.ow2.org/asm/asm</a>.</p>
    <h3 id="overview">2.1 Overview</h3>
    <p>The ASM sources are organized in several directories, with
    one directory per distribution artifact (asm.jar, asm-util.jar,
    etc), plus a few other directories for building, testing and
    benchmarking them:</p>
    <ul>
      <li>
        <code>asm</code>, <code>asm-analysis</code>,
        <code>asm-commons</code>, <code>asm-tree</code>,
        <code>asm-util</code>, and <code>asm-xml</code> contain the
        sources of the corresponding artifacts, together with their
        unit tests. They use the standard <a href=
        "http://maven.apache.org/">Maven</a> directory layout,
        which is also the default layout used by <a href=
        "https://gradle.org/">Gradle</a>.
      </li>
      <li><code>asm-test</code> contains base classes which are
      used in the previous projects to implement the unit tests, as
      well as precompiled Java classes which are used as test cases
      in these projects.</li>
      <li>
        <code>benchmarks</code> defines some <a href=
        "http://openjdk.java.net/projects/code-tools/jmh/">JMH</a>
        benchmarks to measure the performance of ASM, and to
        compare it to previous versions (to make sure there are no
        performance regressions) and to other bytecode manipulation
        libraries.
      </li>
      <li><code>gradle</code> contains the Gradle wrapper and the
      Linux and Windows scripts to invoke it.</li>
      <li>
        <code>tools</code> contains two Gradle projects which are
        used to build the ASM artifacts: a retrofitter tool used to
        retrofit classes compiled with Java 6 into Java 5 class
        files, and a <a href="http://bnd.bndtools.org/">BND</a>
        plugin to generate a module-info.class for each ASM
        artifact. Both tools use ASM itself.
      </li>
    </ul>
    <p>The <code>build.gradle</code> file defines the targets that
    are used to build, test and package the ASM source code. These
    targets are presented in the following sections.</p>
    <h3 id="building">2.2 Building</h3>
    <p>To build everything, use <code>gradle/gradlew build</code>
    from the main directory. To build a single project, for
    instance <code>asm-tree</code>, use <code>gradle/gradlew
    :asm-tree:build</code>. This compiles the code, run the unit
    tests, and perform other checks to make sure that the code is
    properly formatted, that it is binary backward compatible with
    previous ASM versions, and that it is fully covered by unit
    tests.</p>
    <p><small>Note: if the source code formatting verification
    fails, you can fix this by reformatting it with
    <code>gradle/gradlew googleJavaFormat</code>.</small></p>
    <h3 id="tests">2.3 Running tests</h3>
    <p>To test everything, use <code>gradle/gradlew test</code>
    from the main directory. To test a single project, for instance
    <code>asm-util</code>, use <code>gradle/gradlew
    :asm-util:test</code>.</p>
    <p>Test coverage reports can be generated with
    <code>gradle/gradlew jacocoTestReport</code>. The result is
    available in the <code>build/reports/jacoco</code> directory of
    each project.</p>
    <h3 id="distribution">2.4 Creating a distribution</h3>
    <p>A binary distribution, containing the compiled artifacts
    with their Javadoc and sources jar, a POM and digital
    signatures, can be generated with <code>gradle/gradlew
    uploadArchives</code>. The result is generated in the
    <code>/tmp/myRepo</code> directory.</p>
    <p><small>Note: the version number used in the files produced
    when creating a distribution is defined in the header part of
    the <code>build.gradle</code> file.</small></p>
    <h2 id="code">3 Code review</h2>
    <p>This section presents the ASM source code organization, the
    main data structures and the most complex algorithms, which is
    the next important thing to know, after the installation and
    building procedures, in order to contribute to this
    project.</p>
    <h3 id="organization">3.1 Code organization</h3>
    <p>ASM is organized in several packages:</p><a href=
    "asm-package-dependencies.svg" class="image"><img src=
    "asm-package-dependencies.svg" width="90%" alt=
    "Relationships between the ASM packages"></a>
    <ul>
      <li><code>org.objectweb.asm</code> is the core package. It
      defines the ASM visitor API and provides the
      <code>ClassReader</code> and <code>ClassWriter</code> classes
      to read and write compiled Java classes. This package does
      not depend on the other ones and can be used alone.</li>
      <li><code>org.objectweb.asm.signature</code> provides an API
      to read and write generics signatures. It is independent of
      the core package but complements it.</li>
      <li>
        <code>org.objectweb.asm.tree</code> provides a <a href=
        "https://fr.wikipedia.org/wiki/Document_Object_Model">DOM</a>-like
        API on top of the <a href=
        "https://fr.wikipedia.org/wiki/Simple_API_for_XML">SAX</a>-like
        API provided by the core package. It can be used to
        implement complex class transformations, for which the core
        package would be too complicated to use.
      </li>
      <li><code>org.objectweb.asm.tree.analysis</code> provides a
      static bytecode analysis framework on top of the tree
      package. It can be used in addition to the tree package to
      implement really complex class transformations that need to
      know the state of the stack map frames for each
      instruction.</li>
      <li><code>org.objectweb.asm.commons</code> provides some
      useful class adapters that are based on the core and tree
      packages. These adapters can be used as is or can be extended
      to implement more specific class transformations.</li>
      <li><code>org.objectweb.asm.util</code> provides some useful
      class visitors and adapters that can be used for debugging
      purposes. It is generally not needed at runtime.</li>
      <li><code>org.objectweb.asm.xml</code> is deprecated. It
      provided the ability to convert classes to and from XML.</li>
    </ul>
    <p>From an implementation point of view the core package is the
    most complex one. The <code>tree</code>, <code>util</code> and
    <code>xml</code> packages are very simple (they just convert
    classes from one high level representation to another one,
    which is much simpler than converting classes from their byte
    array form to a high level representation one or vice versa).
    The <code>signature</code> package is also quite simple (it
    consists in a parser and a pretty printer for a small grammar).
    In fact the only packages that are not completely trivial,
    except the core package, are the <code>commons</code> and
    <code>analysis</code> packages. But the algorithms used in the
    <code>analysis</code> package are similar to the one explained
    in section <a href="#controlflow">3.5</a>. This explains why
    the rest of this guide is focused on the core package only.</p>
    <h3 id="structures">3.2 Main data structures</h3>
    <h4 id="objectmodel">3.2.1 Object model</h4>
    <p>The core package is made of 28 classes and interfaces. If we
    exclude the <code>Opcodes</code> interface, the 5 abstract
    visitor classes ( <code>AnnotationVisitor</code>,
    <code>ClassVisitor</code>, <code>FieldVisitor</code>,
    <code>MethodVisitor</code> and <code>ModuleVisitor</code>) and
    the 6 utility classes (<code>ConstantDynamic</code>,
    <code>Constants</code>, <code>Handle</code>, <code>Type</code>,
    <code>TypePath</code> and <code>TypeReference</code>), this
    leaves only 16 classes, which are depicted in the figure
    below.</p><a href="asm-package-overview.svg" class=
    "image"><img src="asm-package-overview.svg" width="90%" alt=
    "UML Class Diagram of the main classes of the ASM package"></a>
    <p>The conversion of compiled classes to visit events is done
    by only one class, namely the <code>ClassReader</code> class,
    which uses the auxiliary class <code>Context</code>. The
    inverse process is done by the other 14 classes, which are
    organized around the <code>ClassWriter</code> class:</p>
    <ul>
      <li>Classes:
        <ul>
          <li>the <code>ClassWriter</code> class is the main entry
          point. It contains fields that describe the class
          version, access flags, name, etc. It also contains
          references to other objects that represent the constant
          pool, the fields, the methods, the annotations and the
          attributes of the class.</li>
        </ul>
      </li>
      <li>Constant pool:
        <ul>
          <li>the <code>SymbolTable</code> class is used to
          represent the constant pool and the bootstrap methods, as
          well as an ASM specific type table used to compute stack
          map frames. These structures are represented both in byte
          array form and as a hash set of <code>Symbol</code>
          instances, in order to efficiently test if a given
          constant pool item, bootstrap method or type has already
          been added to the symbol table. This class is referenced
          from the <code>ClassWriter</code>,
          <code>AnnotationWriter</code>, <code>FieldWriter</code>,
          <code>MethodWriter</code> and <code>ModuleWriter</code>
          classes, since classes, annotations, fields, methods and
          modules need to add the constants they reference to the
          constant pool and/or the bootstrap methods.</li>
          <li>the <code>Symbol</code> class is used to represent a
          single constant pool item, a single bootstrap method or a
          single ASM specific type used to compute stack map
          frames.</li>
        </ul>
      </li>
      <li>Fields:
        <ul>
          <li>the <code>FieldWriter</code> class is used to write
          fields. It contains fields that describe the field's
          name, type, signature, value, etc. It also contains
          references to other objects that represent the field's
          annotations and attributes.</li>
        </ul>
      </li>
      <li>Methods:
        <ul>
          <li>the <code>MethodWriter</code> class is used to write
          methods. It contains fields that describe the method's
          name, signature, exceptions, etc. It also contains
          references to other objects that represent the method's
          annotations and attributes. The method's code is stored
          in a byte array that is constructed during the visit of
          bytecode instructions. The labels used to reference
          instructions are stored in a linked list of
          <code>Label</code> instructions.</li>
          <li>the <code>Label</code> class is used to reference
          instructions, but also to represent basic blocks, which
          are used for the automatic computation of the maximum
          stack size and of the stack map frame table of a
          method.</li>
          <li>the <code>Handler</code> class is used to represent
          try catch blocks. Each handler references three
          <code>Label</code> objects that define the start and end
          of the try block, and the start of the catch block.</li>
          <li>the <code>Frame</code> and <code>CurrentFrame</code>
          classes are used for the automatic computation of the
          stack map frames of a method.</li>
          <li>the <code>Edge</code> class is used to represent the
          control flow graph of a method, which is a graph of basic
          blocks, i.e. of <code>Label</code> objects. An
          <code>Edge</code> is an edge between two
          <code>Label</code> objects in this graph.</li>
        </ul>
      </li>
      <li>Modules:
        <ul>
          <li>the <code>ModuleWriter</code> class is used to write
          the <code>Module</code>, <code>ModulePackages</code> and
          <code>ModuleMainClass</code> class attributes, which are
          related to modules (a Java module definition is compiled
          into a class file containing these attributes).</li>
        </ul>
      </li>
      <li>Annotations:
        <ul>
          <li>the <code>AnnotationWriter</code> class is used to
          write annotations. This class is referenced from the
          <code>ClassWriter</code>, <code>FieldWriter</code> and
          <code>MethodWriter</code> classes, since classes, fields
          and methods can have annotations.</li>
        </ul>
      </li>
      <li>Attributes:
        <ul>
          <li>the <code>Attribute</code> class is used to read and
          write non standard class attributes. It must be
          subclassed for each specific non standard attribute that
          must be read and written. This class is referenced from
          the <code>ClassWriter</code>, <code>FieldWriter</code>
          and <code>MethodWriter</code> classes, since classes,
          fields and methods can have attributes.</li>
        </ul>
      </li>
      <li>Resources:
        <ul>
          <li>the <code>ByteVector</code> class is used to
          serialize the class elements while they are visited. It
          is used to represent the constant pool, the annotation
          values, the method's code, the stack map tables, the line
          number tables, etc.</li>
        </ul>
      </li>
    </ul>
    <h4 id="collections">3.2.2 Collections</h4>
    <p>The core package does not use any <code>java.util</code>
    class. Instead, lists, sets and graphs are encoded in dedicated
    fields of their elements:</p>
    <ul>
      <li>Lists are represented as linked lists whose links are
      stored directly in the list elements themselves. For instance
      a list of <code>FieldWriter</code> objects is represented as
      the <code>FieldWriter</code> objects themselves, linked
      through their <code>fv</code> field. Likewise for
      <code>MethodWriter</code>, <code>AnnotationWriter</code>,
      <code>Label</code>, etc. The advantage of this method,
      compared to using separate objects to store the linked list
      itself (as in <code>java.util.LinkedList</code>) is that it
      saves memory. The drawback is that a given element cannot
      belong to several lists at the same time, but this is not a
      problem in the ASM case.</li>
      <li>The only hash set used in the core package, in the
      <code>SymbolTable</code> class, is implemented with an array
      of <code>SymbolTable.Entry</code> instances (a subclass of
      <code>Symbol</code>) that can be chained together through
      their <code>next</code> field (to handle the case of hash
      collisions). In other words, as for lists, the hash set
      structure is embedded in the hash set elements themselves.
      The advantages and drawbacks are the same (saves memory but
      elements cannot belong to several hash sets at once).</li>
      <li>Similarly, the control flow graph (see <a href=
      "#controlflow">section 3.5</a>) data structure is embedded in
      the graph nodes themselves, i.e. in the <code>Label</code>
      objects.
        <p><a href="control-flow-graph-example.svg" class=
        "image"><img src="control-flow-graph-example.svg" width=
        "80%" alt=
        "An example control flow graph representation with labels and edges"></a></p>
        <p>Since <code>Label</code> objects must be stored in
        several data structures at the same time, they have several
        distinct fields that encode these data structures:</p>
        <ul>
          <li>the <code>nextBasicBlock</code> field is used to
          encode the list of labels of a method, in the order they
          are visited.</li>
          <li>the <code>outgoingEdges</code> field is used to store
          the list of <code>Edge</code> objects (linked through
          their <code>nextEdge</code> field) that represent the
          control flow graph data structure.</li>
          <li>the <code>nextListElement</code> field is used to
          store temporary lists of labels in the algorithms used to
          compute the maximum stack size and stack map frames of
          methods (see <a href="#fixpoint">section 3.5.1</a>).
          </li>
        </ul>
      </li>
    </ul>
    <h3 id="algorithms">3.3 Main algorithms</h3>
    <h4 id="classreader">3.3.1 ClassReader</h4>
    <p>The <code>ClassReader</code> algorithm is quite
    straightforward. It is summarized below.</p>
    <ul>
      <li>parse the constant pool and the bootstrap methods (in the
      constructor):</li>
      <ul>
        <li>store the start offset of each constant pool item in
        <code>cpInfoOffsets</code></li>
        <li>store the start offset of each bootstrap method in
        <code>bootstrapMethodOffsets</code></li>
        <li>store the size of the longest string constant in
        <code>maxStringLength</code></li>
      </ul>
      <li>parse the class (in the <code>accept</code> and
      <code>read</code>* methods):</li>
      <ul>
        <li>parse the header</li>
        <li>parse the class attributes. Depending on the complexity
        of the attribute:</li>
        <ul>
          <li>either parse it and store its value in a local
          variable (for attributes containing a simple value),</li>
          <li>or store its start offset in a local variable (for
          attributes with a complex structure)</li>
        </ul>
        <li>call the visit methods corresponding to the detected
        attributes. For complex attributes, which were not parsed
        in the previous step (such as annotations), parse them and
        visit them at the same time: i.e. parse one part, visit it,
        parse the next part, visit it, etc.</li>
        <li>for each field (in the <code>readField</code>
        method):</li>
        <ul>
          <li>parse the header</li>
          <li>parse the field attributes. Depending on the
          attribute:</li>
          <ul>
            <li>either parse it and store its value in a local
            variable,</li>
            <li>or store its start offset in a local variable</li>
          </ul>
          <li>call <code>visitField</code></li>
          <li>call the visit methods corresponding to the detected
          attributes. For complex attributes, which were not parsed
          in the previous step (such as annotations), parse them
          and visit them at the same time: i.e. parse one part,
          visit it, parse the next part, visit it, etc.</li>
          <li>call <code>visitEnd</code></li>
        </ul>
        <li>for each method (in the <code>readMethod</code>
        method):</li>
        <ul>
          <li>parse the header</li>
          <li>parse the method attributes. Depending on the
          attribute:</li>
          <ul>
            <li>either parse it and store its value in a local
            variable,</li>
            <li>or store its start offset in a local variable</li>
          </ul>
          <li>call <code>visitMethod</code></li>
          <li>if the returned visitor is a
          <code>MethodWriter</code>, and if its
          <code>ClassWriter</code>'s constant pool was copied from
          this reader (see <a href="#classwriter">section
          3.3.2</a>), the method bytes can be copied as is: then
          skip all steps below.
          </li>
          <li>call the visit methods corresponding to the detected
          attributes. For complex attributes, which were not parsed
          in the previous step (such as annotations), parse them
          and visit them at the same time: i.e. parse one part,
          visit it, parse the next part, visit it, etc.</li>
          <li>for the special case of the <code>Code</code>
          attribute (in the <code>readCode</code> method):</li>
          <ul>
            <li>find the labels and store them in the
            <code>Context.currentMethodLabels</code> array</li>
            <ul>
              <li>look for labels in the code</li>
              <li>look for labels in the exception handlers</li>
              <li>look for labels in the line number and local
              variable tables</li>
              <li>look for labels in the other code attributes</li>
            </ul>
            <li>if there is a stack map table, parse the first
            frame</li>
            <li>parse the instructions</li>
            <ul>
              <li>if there is a stack map frame for this offset,
              call <code>visitFrame</code>, and parse the next
              frame</li>
              <li>if there is a label for this offset, call
              <code>visitLabel</code></li>
              <li>if there is a line number entry for this offset,
              call <code>visitLineNumber</code></li>
              <li>call
              <code>visit</code><i>Xxx</i><code>Insn</code></li>
            </ul>
            <li>call <code>visitAttribute</code> for each non
            standard code attribute parsed during second step</li>
            <li>call <code>visitMaxs</code></li>
            <li>call <code>visitEnd</code></li>
          </ul>
          <li>call <code>visitEnd</code></li>
        </ul>
        <li>call <code>visitEnd</code></li>
      </ul>
    </ul>
    <p>Some points are interesting to note:</p>
    <ul>
      <li>the visit of line numbers and stack map frames is
      interleaved with the visit of instructions. In the case of
      stack map frames, not only the visit, but also the
      <i>parsing</i> of the stack map table and of the method's
      code is interleaved. The advantage, compared to a parsing of
      the stack map table followed by a parsing of the method's
      code, is that no complex data structure is needed to store
      the parsed frames for the second step.</li>
      <li>constant pool items are parsed every time they are
      referenced, except for Utf8 and ConstantDynamic items, whose
      values are cached in the <code>cpInfoValues</code> array. Not
      also that a single char array is reused to parse these items.
      It must be large enough to parse the longest string, hence
      the computation of <code>maxStringLength</code> in the
      constructor.</li>
    </ul>
    <h4 id="classwriter">3.3.2 ClassWriter, AnnotationWriter,
    FieldWriter, MethodWriter and ModuleWriter</h4>
    <p>Since the visit of the class members can be interleaved (it
    is possible to start visiting a field, then start visiting a
    method, go back to visit annotations of the field, continue
    with some instructions of the method, visit attributes of the
    field, add new instructions to the method, and so on), it is
    not possible to construct the class file's byte array in a
    sequential order, from beginning to end. Instead it is
    necessary to use several byte vectors that can grow
    simultaneously. This is why there are several writer classes,
    unlike for the reader case.</p>
    <p>The <code>ClassWriter</code> class is the main entry point.
    It contains the class header elements and the lists of its
    fields and methods, as well as a <code>SymbolTable</code>
    instance, containing the constant pool items and the bootstrap
    methods of the class. This symbol table uses a hash set of
    <code>Symbol</code> objects, in order to avoid adding the same
    item several times in the constant pool or in the bootstrap
    methods array. The symbol table can be created from an existing
    class by passing a <code>ClassReader</code> argument to its
    constructor. This allows unchanged methods to be copied as is
    from a class reader to a class writer, without visiting their
    content (see <a href="#classreader">section 3.3.1</a>).</p>
    <p>The <code>AnnotationWriter</code>, <code>FieldWriter</code>
    and <code>ModuleWriter</code> classes are quite simple: they
    convert visit events to a byte array representation, by using
    the class writer's <code>SymbolTable</code> in order to add
    constant pool items when necessary. The most complex writer
    class is the <code>MethodWriter</code> class, because it
    manages advanced features such as the automatic computation of
    the maximum stack size and number of local variables of a
    method, the automatic computation of its stack map frames, as
    well as the automatic management of short versus long jump
    instructions. Without these features, each
    <code>visit<i>Xxx</i>Insn</code> method would be very simple,
    i.e. it would just add the bytecode representation of an
    instruction to the <code>code</code> byte vector.</p>
    <p>Instead, in order to be able to automatically compute the
    maximum stack size, the maximum number of local variables and
    the stack map frames, each <code>visit<i>Xxx</i>Insn</code>
    method does the following:</p>
    <ul>
      <li>append the instruction to the <code>code</code> byte
      vector</li>
      <li>
        <code>if (currentBasicBlock != null) // if some automatic
        computation is needed</code>
        <ul>
          <li>
            <code>if (compute == COMPUTE_ALL_FRAMES || compute ==
            COMPUTE_INSERTED_FRAMES)</code>
            <ul>
              <li>simulate the execution of this instruction on the
              stack frame</li>
            </ul>
          </li>
          <li>
            <code>else // compute ==
            COMPUTE_MAX_STACK_AND_LOCAL</code>
            <ul>
              <li>simulate the execution of this instruction on the
              stack <i>height</i></li>
            </ul>
          </li>
          <li>keep track of the local variables used, if any</li>
          <li>keep track of the successors of this instruction</li>
          <li>update <code>currentBasicBlock</code></li>
        </ul>
      </li>
    </ul>
    <p>The maximum stack size or the stack map frames are actually
    computed in the <code>computeMaxStackAndLocal</code> and
    <code>computeAllFrames</code> methods, by using the control
    flow graph constructed in the <code>visit<i>Xxx</i>Insn</code>
    methods (see <a href="#controlflow">section 3.5</a> for more
    details).</p>
    <h4 id="label">3.3.3 Label</h4>
    <p>From a user point of view the <code>Label</code> class is
    used to reference instructions. Internally it is used to store
    the bytecode offset of an instruction (i.e. the bytecode array
    index of the first byte of the instruction), and to compute
    relative bytecode offsets (i.e. the difference between the
    bytecode offsets of two instructions). It is also used to
    represent basic blocks, which are used for the automatic
    computation of the maximum stack size and of the stack map
    frames of a method (see <a href="#controlflow">section
    3.5</a>).</p>
    <p>Jump instructions such as <code>IFEQ</code> or
    <code>GOTO</code> are stored in bytecode as an opcode followed
    by a relative bytecode offset to the target instruction (this
    relative offset is the difference between the bytecode offset
    of the target instruction and the bytecode offset of the jump
    instruction). This relative offset can be computed easily in
    the case of a backward jump (i.e. a jump to an instruction that
    is before the jump instruction in the bytecode), but it cannot
    be computed at all in the case of a forward jump (i.e. a jump
    to an instruction that is after the jump instruction) since, in
    this case, the target instruction has not been visited yet, and
    so its bytecode offset is unknown. The case of forward jumps is
    solved in the following way:</p>
    <ul>
      <li>The jump instruction is written with a (temporary)
      relative offset equal to 0.</li>
      <li>The target <code>Label</code> object is updated to
      memorize the fact that this jump instruction makes a forward
      reference to this label (the <code>forwardReferences</code>
      array in <code>Label</code> is used for that).</li>
      <li>When this label is visited, i.e. when its bytecode offset
      becomes known, all the forward jump instructions to this
      label (given by <code>forwardReferences</code>) are updated,
      to replace the temporary relative offsets with their real
      values, which can now be computed.</li>
    </ul>
    <h4 id="toByteArray">3.3.4 toByteArray</h4>
    <p>The <code>toByteArray</code> method in
    <code>ClassWriter</code> puts together all the pieces
    constructed in the various writer classes in order to get the
    full byte representation of the class. This is done in two
    steps:</p>
    <ul>
      <li>the size of the class is computed by summing the size of
      all the pieces, which is given by the <code>getSize</code>
      method (this method can add items to the constant pool, which
      modifies its size; this is why the constant pool size is
      added only at the very end).</li>
      <li>a byte vector of this size is allocated, and the pieces
      are copied into this vector in the right order. This is done
      by calling the <code>put<i>Xxx</i></code> method on each
      piece (e.g. <code>putFieldInfo</code> on each
      <code>FieldWriter</code>).</li>
    </ul>
    <h3 id="jumpencoding">3.4 Jump instructions encoding
    algorithm</h3>
    <p>The jump instructions such as <code>IFEQ</code> and
    <code>GOTO</code> store relative bytecode offsets with signed
    values encoded in two bytes. This offset can therefore vary
    between -32768 and 32767. However the bytecode of a method can
    be as large as 65535 bytes: it is therefore possible to have
    relative bytecode offsets that cannot be represented with
    signed, two bytes values. Hopefully there are two special jump
    instructions that store their relative bytecode offset in
    signed, four bytes values, namely <code>GOTO_W</code> and
    <code>JSR_W</code>.</p>
    <p>In the case of backward jumps the jump offset is known when
    the jump instruction is visited. It is then easy to use
    <code>GOTO</code> or <code>GOTO_W</code>, depending on the
    value of this relative offset. But in the case of forward jumps
    this is not possible. A first solution is to assume that this
    offset will require 4 bytes, and to always use a
    <code>GOTO_W</code> for forward jumps. But this is not very
    optimal. A second solution is to assume that this offset will
    require 2 bytes, and to use a normal jump instruction, with 2
    bytes reserved to store the offset when it becomes known. The
    problem is that if the offset turns out to require 4 bytes, the
    jump instruction must be replaced with another one using a 4
    bytes offset, which can invalidate already computed offsets
    used in other jump instructions. In ASM the second solution was
    chosen. It requires a method to replace the forward jump
    instructions that turn out to require long offsets. The
    algorithm used for this is presented in the rest of this
    section.</p>
    <h4 id="jumpencodingbasic">3.4.1 Basic algorithm</h4>
    <p>The algorithm uses the following properties:</p>
    <ul>
      <li>the maximum method size, and therefore forward jump
      offset, is 65535, which can be stored in an <i>unsigned</i>
      two bytes value,</li>
      <li>the opcodes of the JVM bytecode instructions set do not
      use all the 255 possible values and, in fact, there are
      enough unused opcodes to define an <i>unsigned</i> equivalent
      of each standard jump instruction opcode (that we note
      <code>ASM_GOTO</code>, <code>ASM_JSR</code>,
      <code>ASM_IFEQ</code>, and so on).</li>
    </ul>
    <p>Given these properties, if it turns out, in
    <code>visitLabel</code>, that a forward offset is greater than
    32737, the opcode of the corresponding instruction is changed
    to the equivalent non standard opcode with unsigned offset, and
    the offset is stored as an unsigned short.</p>
    <p>Then, when all the class has been visited and converted to a
    byte array, if some non standard opcodes have been used, they
    must be replaced with standard ones. For this:</p>
    <ul>
      <li>the content of the <code>ClassWriter</code> is cleared
      (except its symbol table), and the byte array is parsed with
      a <code>ClassReader</code> chained to this
      <code>ClassWriter</code>, to rebuild the class. The class is
      parsed with the special <code>EXPAND_ASM_INSNS</code> class
      reader flag, whose effect is explained below.</li>
      <li>the class reader converts the ASM specific instructions
      to standard ones, with explicit <code>GOTO_W</code> and
      <code>JSR_W</code> instructions and, because of the
      <code>EXPAND_ASM_INSNS</code> flag, leaves the existing
      <code>GOTO_W</code> and <code>JSR_W</code> instructions
      unchanged (normally they are converted to <code>GOTO</code>
      and <code>JSR</code>, but not here, since we know 4 bytes
      offsets will be needed - this is also needed to avoid
      infinite loops where the <code>ClassWriter</code> is cleared
      and reconstructed indefinitely).</li>
    </ul>
    <p>This process removes the existing ASM specific instructions,
    but can introduce new ones. Indeed, because the ASM specific
    instructions are replaced with longer sequences of standard
    instructions, some relative offsets between existing
    instructions, which were just below the 32737 limit, can become
    larger than this limit. In this case the process is repeated:
    the byte array containing the new ASM specific instructions is
    parsed again with a new <code>ClassReader</code> (after the
    <code>ClassWriter</code> content has been cleared) chained to
    the <code>ClassWriter</code>. Eventually this process will
    converge and the result will be a class with only standard
    instruction opcodes.</p>
    <h4 id="jumpencodingimpact">3.4.2 Impact on stack map
    frames</h4>
    <p>An <code>IF</code><i>Xxx</i> instruction with a forward
    offset larger than 32767 must be replaced with an
    <code>IF</code><i>NotX</i> <code>GOTO_W</code> sequence, which
    requires a stack map frame after the <code>GOTO_W</code> (for
    Java 7 or more classes). This stack map frame may not be
    already present, in which case it needs to be computed and
    inserted. For this, one solution would be to recompute all the
    stack map frames, but this is not always possible (computing
    the stack map frames may require access to the class hierarchy,
    may load classes, etc) and would not be efficient. Instead, we
    use the existing stack map frames to compute the one we need to
    insert. Indeed, by definition, the existing stack map frames
    are sufficient to compute the state of the local variables and
    of the stack at each instruction, with a linear algorithm
    parsing the instructions and the frames from the beginning to
    the end.</p>
    <p>This is implemented as follows:</p>
    <ul>
      <li>when the <code>ClassWriter</code> is cleared to replace
      the ASM specific instructions, it is put in a
      <code>COMPUTE_INSERTED_FRAMES</code> mode.</li>
      <li>in this mode, the <code>MethodWriter</code> uses a
      <code>CurrentFrame</code> instead of a <code>Frame</code> to
      simulate the execution of each instruction, which has the
      effect of computing explicitly the state of the local
      variables and of the stack at each <i>instruction</i>
      (normally, in <code>COMPUTE_FRAMES</code> mode, this explicit
      state is only computed at the basic block level, not at the
      instruction level). The existing frames are also used as is,
      to replace the <code>CurrentFrame</code> with the visited
      frame. Finally, if a frame with the special type
      <code>F_INSERT</code> is visited, then the current frame
      state is used to insert a frame at the current bytecode
      offset.</li>
      <li>in the <code>ClassReader</code> used to replace the ASM
      specific instructions, when an <code>IF</code><i>Xxx</i>
      instruction is replaced with an <code>IF</code><i>NotX</i>
      <code>GOTO_W</code> sequence, a <code>visitFrame(F_INSERT,
      ...)</code> is emitted, with an empty content, in order to
      insert a frame at this location.</li>
    </ul>
    <h4 id="jumpencodingexample">3.4.3 An example</h4>
    <p>Consider the following Java code:</p>
    <pre>public void m(int i, int j) {
    for (; cond(i); --i) {
        if (j == 0) {
            break;
        }
        ...
    }
}
</pre>
    <p>It is compiled into:</p>
    <pre>public m(II)V
  GOTO L1
 L2
  ILOAD 2
  IFNE L3
  GOTO L4
 L3
  ...
  IINC 1 -1
 L1
  ALOAD 0
  ILOAD 1
  INVOKEVIRTUAL C.cond(I)Z
  IFNE L2
 L4
  RETURN
</pre>
    <p>During the visit of each instruction, offsets are computed
    step by step as follows:</p>
    <table class="jumpencoding">
      <tbody>
        <tr>
          <th>Offset</th>
          <th>Instruction</th>
          <th>Comment</th>
        </tr>
        <tr>
          <td>0</td>
          <td><code>&nbsp;GOTO L1</code></td>
          <td>relative offset unknown when this instruction is
          visited</td>
        </tr>
        <tr>
          <td>3</td>
          <td><code>L2</code></td>
          <td></td>
        </tr>
        <tr>
          <td>3</td>
          <td><code>&nbsp;ILOAD 2</code></td>
          <td></td>
        </tr>
        <tr>
          <td>4</td>
          <td><code>&nbsp;IFNE L3</code></td>
          <td>relative offset unknown when this instruction is
          visited</td>
        </tr>
        <tr>
          <td>7</td>
          <td><code>&nbsp;GOTO L4</code></td>
          <td>relative offset unknown when this instruction is
          visited</td>
        </tr>
        <tr>
          <td>10</td>
          <td><code>L3</code></td>
          <td>relative offset for <code>IFNE L3</code> becomes
          known: 10 - 4 = 6</td>
        </tr>
        <tr>
          <td>10</td>
          <td><code>&nbsp;</code>...</td>
          <td></td>
        </tr>
        <tr>
          <td>32764</td>
          <td><code>&nbsp;IINC 1 -1</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32767</td>
          <td><code>L1</code></td>
          <td>relative offset for <code>GOTO L1</code> becomes
          known: 32767 - 0 = 32767</td>
        </tr>
        <tr>
          <td>32767</td>
          <td><code>&nbsp;ALOAD 0</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32768</td>
          <td><code>&nbsp;ILOAD 1</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32769</td>
          <td><code>&nbsp;INVOKEVIRTUAL</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32772</td>
          <td><code>&nbsp;IFNE L2</code></td>
          <td>relative offset = 3 - 32772 = -32769</td>
        </tr>
        <tr>
          <td></td>
          <td><code>L4</code></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td><code>&nbsp;RETURN</code></td>
          <td></td>
        </tr>
      </tbody>
    </table>
    <p>The offset computed for <code>IFNE L2</code> is -32769,
    which cannot be stored in a short. The instruction is therefore
    transformed into <code>IFEQ</code> <code>GOTO_W L2</code> on
    the fly:</p>
    <table class="jumpencoding">
      <tbody>
        <tr>
          <td>0</td>
          <td><code>&nbsp;GOTO L1</code></td>
          <td>relative offset = 32767, changed during visit of
          <code>L1</code></td>
        </tr>
        <tr>
          <td>3</td>
          <td><code>L2</code></td>
          <td></td>
        </tr>
        <tr>
          <td>3</td>
          <td><code>&nbsp;ILOAD 2</code></td>
          <td></td>
        </tr>
        <tr>
          <td>4</td>
          <td><code>&nbsp;IFNE L3</code></td>
          <td>relative offset = 6, changed during visit of
          <code>L3</code></td>
        </tr>
        <tr>
          <td>7</td>
          <td><code>&nbsp;GOTO L4</code></td>
          <td>relative offset still unknown</td>
        </tr>
        <tr>
          <td>10</td>
          <td><code>L3</code></td>
          <td></td>
        </tr>
        <tr>
          <td>10</td>
          <td><code>&nbsp;</code>...</td>
          <td></td>
        </tr>
        <tr>
          <td>32764</td>
          <td><code>&nbsp;IINC 1 -1</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32767</td>
          <td><code>L1</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32767</td>
          <td><code>&nbsp;ALOAD 0</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32768</td>
          <td><code>&nbsp;ILOAD 1</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32769</td>
          <td><code>&nbsp;INVOKEVIRTUAL</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32772</td>
          <td><code>&nbsp;IFEQ L4</code></td>
          <td>relative offset = 8</td>
        </tr>
        <tr>
          <td>32775</td>
          <td><code>&nbsp;GOTO_W L2</code></td>
          <td>relative offset = 3 - 32775 = -32772</td>
        </tr>
        <tr>
          <td>32780</td>
          <td><code>L4</code></td>
          <td>relative offset for <code>GOTO L4</code> becomes
          known: 32780 - 7 = 32773</td>
        </tr>
        <tr>
          <td></td>
          <td><code>&nbsp;RETURN</code></td>
          <td></td>
        </tr>
      </tbody>
    </table>
    <p>When <code>L4</code> is reached the offset computed for
    <code>GOTO L4</code> becomes knwown: we get 32773, which cannot
    be stored as a signed short. As explained in <a href=
    "#jumpencodingbasic">section 3.4.1</a>, the <code>GOTO</code>
    instruction is then replaced with a non standard
    <code>ASM_GOTO</code> instruction, whose offset is stored as an
    unsigned short:</p>
    <table class="jumpencoding">
      <tbody>
        <tr>
          <td>0</td>
          <td><code>&nbsp;GOTO L1</code></td>
          <td>relative offset = 32767, changed during visit of
          <code>L1</code></td>
        </tr>
        <tr>
          <td>3</td>
          <td><code>L2</code></td>
          <td></td>
        </tr>
        <tr>
          <td>3</td>
          <td><code>&nbsp;ILOAD 2</code></td>
          <td></td>
        </tr>
        <tr>
          <td>4</td>
          <td><code>&nbsp;IFNE L3</code></td>
          <td>relative offset = 6, changed during visit of
          <code>L3</code></td>
        </tr>
        <tr>
          <td>7</td>
          <td><code class="red">&nbsp;ASM_GOTO L4</code></td>
          <td>relative offset = 32773, changed during visit of
          <code>L4</code></td>
        </tr>
        <tr>
          <td>10</td>
          <td><code>L3</code></td>
          <td></td>
        </tr>
        <tr>
          <td>10</td>
          <td><code>&nbsp;</code>...</td>
          <td></td>
        </tr>
        <tr>
          <td>32764</td>
          <td><code>&nbsp;IINC 1 -1</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32767</td>
          <td><code>L1</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32767</td>
          <td><code>&nbsp;ALOAD 0</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32768</td>
          <td><code>&nbsp;ILOAD 1</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32769</td>
          <td><code>&nbsp;INVOKEVIRTUAL</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32772</td>
          <td><code>&nbsp;IFEQ L4</code></td>
          <td>relative offset = 8</td>
        </tr>
        <tr>
          <td>32775</td>
          <td><code>&nbsp;GOTO_W L2</code></td>
          <td>relative offset = 3 - 32775 = -32772</td>
        </tr>
        <tr>
          <td>32780</td>
          <td><code>L4</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32780</td>
          <td><code>&nbsp;RETURN</code></td>
          <td></td>
        </tr>
      </tbody>
    </table>
    <p>Since the bytecode contains at least one non standard
    instruction, the <code>ClassWriter</code> content is cleared,
    just after the byte array representation of the class has been
    computed (in <code>toByteArray</code>), and reconstructed again
    by parsing the byte array with a <code>ClassReader</code>
    chained to this <code>ClassWriter</code>. During this process
    the <code>ClassReader</code> converts the <code>ASM_GOTO</code>
    into a <code>GOTO_W</code> (and preserves the existing
    <code>GOTO_W</code>). When <code>L1</code> is reached, we
    get:</p>
    <table class="jumpencoding">
      <tbody>
        <tr>
          <td>0</td>
          <td><code>&nbsp;GOTO L1</code></td>
          <td>relative offset unknown</td>
        </tr>
        <tr>
          <td>3</td>
          <td><code>L2</code></td>
          <td></td>
        </tr>
        <tr>
          <td>3</td>
          <td><code>&nbsp;ILOAD 2</code></td>
          <td></td>
        </tr>
        <tr>
          <td>4</td>
          <td><code>&nbsp;IFNE L3</code></td>
          <td>relative offset = 8, changed during visit of
          <code>L3</code></td>
        </tr>
        <tr>
          <td>7</td>
          <td><code>&nbsp;GOTO_W L4</code></td>
          <td>relative offset unknown</td>
        </tr>
        <tr>
          <td>12</td>
          <td><code>L3</code></td>
          <td></td>
        </tr>
        <tr>
          <td>12</td>
          <td><code>&nbsp;</code>...</td>
          <td></td>
        </tr>
        <tr>
          <td>32766</td>
          <td><code>&nbsp;IINC 1 -1</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32769</td>
          <td><code>L1</code></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td><code>&nbsp;ALOAD 0</code></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td><code>&nbsp;ILOAD 1</code></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td><code>&nbsp;INVOKEVIRTUAL</code></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td><code>&nbsp;IFEQ L4</code></td>
          <td>relative offset = 8</td>
        </tr>
        <tr>
          <td></td>
          <td><code>&nbsp;GOTO_W L2</code></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td><code>L4</code></td>
          <td></td>
        </tr>
        <tr>
          <td></td>
          <td><code>&nbsp;RETURN</code></td>
          <td></td>
        </tr>
      </tbody>
    </table>
    <p>At this point the relative offset for <code>GOTO L1</code>
    becomes known, namely 32769. This is too large for a signed
    short offset, so <code>GOTO L1</code> is replaced with
    <code>ASM_GOTO L1</code> with an unsigned short offset. The
    class parsing and reconstruction then continues, and eventually
    a new byte array for the class is produced. Since it still
    contains a non standard opcode, the same process is repeated:
    the <code>ClassWriter</code> content is cleared and
    reconstructed by parsing the byte array with a
    <code>ClassReader</code>. Thanks to the special
    <code>EXPAND_ASM_INSNS</code> flag, <code>GOTO_W</code> and
    <code>JSR_W</code> are never converted back to
    <code>GOTO</code> or <code>JSR</code>, which ensures that this
    iterative process will eventually converge. In our example, the
    second iteration does not produce any new non standard opcode,
    and we get the final result:</p>
    <table class="jumpencoding">
      <tbody>
        <tr>
          <td>0</td>
          <td><code>&nbsp;GOTO_W L1</code></td>
          <td>relative offset = 32771</td>
        </tr>
        <tr>
          <td>5</td>
          <td><code>L2</code></td>
          <td></td>
        </tr>
        <tr>
          <td>5</td>
          <td><code>&nbsp;ILOAD 2</code></td>
          <td></td>
        </tr>
        <tr>
          <td>6</td>
          <td><code>&nbsp;IFNE L3</code></td>
          <td>relative offset = 8</td>
        </tr>
        <tr>
          <td>9</td>
          <td><code>&nbsp;GOTO_W L4</code></td>
          <td>relative offset = 32775</td>
        </tr>
        <tr>
          <td>14</td>
          <td><code>L3</code></td>
          <td></td>
        </tr>
        <tr>
          <td>14</td>
          <td><code>&nbsp;</code>...</td>
          <td></td>
        </tr>
        <tr>
          <td>32768</td>
          <td><code>&nbsp;IINC 1 -1</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32771</td>
          <td><code>L1</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32771</td>
          <td><code>&nbsp;ALOAD 0</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32772</td>
          <td><code>&nbsp;ILOAD 1</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32773</td>
          <td><code>&nbsp;INVOKEVIRTUAL</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32776</td>
          <td><code>&nbsp;IFEQ L4</code></td>
          <td>reative offset = 8</td>
        </tr>
        <tr>
          <td>32779</td>
          <td><code>&nbsp;GOTO_W L2</code></td>
          <td>relative offset = -32774</td>
        </tr>
        <tr>
          <td>32784</td>
          <td><code>L4</code></td>
          <td></td>
        </tr>
        <tr>
          <td>32784</td>
          <td><code>&nbsp;RETURN</code></td>
          <td></td>
        </tr>
      </tbody>
    </table>
    <h3 id="controlflow">3.5 Control and data flow analysis
    algorithm</h3>
    <p>This section presents the algorithm used to compute the
    maximum stack size and the stack map frames of a method. This
    algorithm is a control and data flow analysis algorithm, based
    on the decomposition of the method into a <i>control flow
    graph</i> of <i>basic blocks</i>. A basic block is a sequence
    of instructions where only the first instruction is the target
    of a jump instruction, and where only the last instruction can
    jump to other basic blocks. The control flow graph of a method
    is the graph whose nodes are the basic blocks, and whose edges
    connect the basic blocks that are linked by jump instructions.
    This graph is constructed during the visit of each instruction.
    As an example, the control flow graph of the method defined in
    <a href="#fixpoint">section 3.5.1</a> is the one shown in
    <a href="#installation">section 2</a>.</p>
    <p>In the following we explain the algorithm used to compute
    the stack map frames, implemented in the
    <code>computeAllFrames</code> method. The algorithm to compute
    the maximum stack size, implemented in the
    <code>computeMaxStackAndLocal</code> method, is similar but
    simpler (since only the size of the stack is needed), so it is
    not detailed here (except for the handling of subroutines).</p>
    <h4 id="fixpoint">3.5.1 Basic data flow analysis algorithm</h4>
    <p>Stack map frames are computed in a two steps process:</p>
    <ul>
      <li>During the visit of each instruction, the state of the
      frame at the end of the current basic block is updated by
      simulating the action of the instruction on the previous
      state of this so called "output frame".</li>
      <li>In <code>computeAllFrames</code>, a fix point algorithm
      is used to compute the "input frame" of each basic block,
      i.e. the stack map frame at the beginning of the basic block,
      starting from the input frame of the first basic block (which
      is computed from the method descriptor), and by using the
      previously computed output frames to compute the input state
      of the other blocks.</li>
    </ul>
    <p>Let's take a simple example in order to explain the details
    of this algorithm. Consider the following very simple method
    (where B is a subclass of A):</p>
    <pre>public static m(Z)LA;
  GETSTATIC B.VALUE : LB;
  ASTORE 1
  GOTO L0
 L1
  GETSTATIC A.VALUE : LA;
  ASTORE 1
 L0
  ILOAD 0
  IFNE L1
  ALOAD 1
  ARETURN
</pre>
    <h5 id="firststep">First step</h5>
    <p>As stated above, during the first step of the algorithm,
    which takes place in each <code>visit<i>Xxx</i>Insn</code>
    method in <code>ClassWriter</code>, the state of the output
    frame of each basic block is updated by simulating the action
    of the visited instruction. It is important to note that the
    algorithm works at the basic block level, and not at the
    instruction level. This means that input and output frames are
    associated to basic blocks, and not to individual instructions.
    In practice, they are stored in a <code>Frame</code> object
    that is associated to a <code>Label</code> object, which marks
    the beginning of basic blocks.</p>
    <p>The effect of this first step for the above example method
    is illustrated on the table below:</p>
    <table>
      <tbody>
        <tr>
          <th>Label</th>
          <th>Instruction</th>
          <th>Output frame</th>
          <th>Comment</th>
        </tr>
        <tr>
          <td></td>
          <td><code>GETSTATIC B.VALUE : LB;</code></td>
          <td>O1 = [??] [?B]</td>
          <td>getstatic pushes a value of type B on the stack</td>
        </tr>
        <tr>
          <td></td>
          <td><code>ASTORE 1</code></td>
          <td>O1 = [?B] [?]</td>
          <td>astore consumes this value and stores it in local
          1</td>
        </tr>
        <tr>
          <td></td>
          <td><code>GOTO L0</code></td>
          <td>O1 = [?B] [?]</td>
          <td>goto does not change the frame</td>
        </tr>
        <tr>
          <td colspan="4">&nbsp;</td>
        </tr>
        <tr>
          <td><code>L1</code></td>
          <td><code>GETSTATIC A.VALUE : LA;</code></td>
          <td>O2 = [??] [?A]</td>
          <td>each basic block starts with a new, unknown
          frame</td>
        </tr>
        <tr>
          <td></td>
          <td><code>ASTORE 1</code></td>
          <td>O2 = [?A] [?]</td>
          <td>astore stores the value produced by getstatic in
          local 1</td>
        </tr>
        <tr>
          <td colspan="4">&nbsp;</td>
        </tr>
        <tr>
          <td><code>L0</code></td>
          <td><code>ILOAD 0</code></td>
          <td>O3 = [??] [?I]</td>
          <td>iload pushes the value of local 0, which is of type
          int</td>
        </tr>
        <tr>
          <td></td>
          <td><code>IFNE L1</code></td>
          <td>O3 = [??] [?]</td>
          <td>ifne consumes this value</td>
        </tr>
        <tr>
          <td colspan="4">&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td><code>ALOAD 1</code></td>
          <td>O4 = [??] [?L1]</td>
          <td>aload pushes the value of local 1, which is
          unknown</td>
        </tr>
        <tr>
          <td></td>
          <td><code>ARETURN</code></td>
          <td>O4 = [??] [?]</td>
          <td>areturn consumes this value</td>
        </tr>
      </tbody>
    </table>
    <p>At the beginning, the output frame O1 of the first basic
    block is completely unknown. During the visit of the first
    instruction, the action of <code>GETSTATIC</code> is simulated:
    the result is that a new value of type B is pushed on the
    stack, on top of the previous values (although we know here
    that the stack is initially empty, we do not take this into
    account and do as if the stack could previously contain any
    number of values of any type - hence the [<b>?</b>B]). During
    the visit of the second instruction, the output frame O1 is
    updated to simulate the effect of <code>ASTORE</code>: the
    result is that the value previously pushed on the stack is
    popped and stored in the local variable 1. The visit of the
    third instruction does not change the output frame O1, but
    changes the current basic block to <code>null</code>.</p>
    <p>The visit of the L1 label makes L1 become the new current
    basic block. Like for the first basic block, the output frame
    O2 of this basic block is initially completely unknown. The
    visit of the instructions of this basic block is then similar
    to the visit of the previous instructions.</p>
    <p>The visit of the L0 label makes L0 become the new current
    basic block. Here again we start with a completely unknown
    output frame O3 although, in this case, we could start from the
    value of O2 (since this basic block is a successor of the
    previous one). The <code>ILOAD</code> instruction loads the
    value of local variable 0, which is necessarily of type int
    (the whole algorithm is based on the assumption that the code
    is correct), and pushes it on the stack. The <code>IFNE</code>
    instruction consumes this value.</p>
    <p>Another effect of simulating the action of the
    <code>IFNE</code> instruction is to create a new basic block,
    and to make it the new current basic block. This is why,
    although there is no label just after this instruction, the
    basic block changes. Here again, the output frame O4 of this
    basic block is initially completely unknown (although, as
    before and for the same reason, we could start from the value
    of O3). The <code>ALOAD</code> instruction loads the value of
    local variable 1, whose type is unknown since the frame is
    initially completely unknown. The only thing we know is that,
    after the execution of this method, the stack contains one
    additional value whose type is the type of local variable 1
    before this instruction was executed (hence the
    [?<b>L1</b>]).</p>
    <h5 id="secondstep">Second step</h5>
    <p>During the second step of the algorithm, which takes place
    in the <code>computeAllFrames</code> method, the input frames
    of each basic block are computed by using an iterative fix
    point algorithm (i.e. an algorithm to find a fix point <i>x</i>
    of a function <i>f</i>, defined by <i>f(x)=x</i>. If <i>x</i>
    values define a complete lattice and if <i>f</i> is monotonic,
    <i>x<sub>n+1</sub>=f(x<sub>n</sub>)</i> converges to the
    smallest fix point of <i>f</i>, according to the <a href=
    "http://en.wikipedia.org/wiki/Knaster%E2%80%93Tarski_theorem">Tarski</a>
    theorem. Here <i>x</i> is a control flow graph with input and
    output frames, <i>f</i> is a "merge" function and the order
    relation is based on the subtyping relation for the
    verification type system). First the input frame I1 of the
    first basic block is computed from the method descriptor
    "public static m(Z)LA;", which gives I1 = [I] []. Then the
    first basic block is marked as "changed", and the fix point
    algorithm starts:</p>
    <table>
      <tbody>
        <tr>
          <th>Iteration</th>
          <th>Changed</th>
          <th>Output frames</th>
          <th>Input frames</th>
          <th>Comment</th>
        </tr>
        <tr>
          <td>0</td>
          <td>B1</td>
          <td>O1 = [?B] [?]<br>
          O2 = [?A] [?]<br>
          O3 = [??] [?]<br>
          O4 = [??] [?]</td>
          <td><b>I1= [I-] []</b><br>
          I2 = [??] [?]<br>
          I3 = [??] [?]<br>
          I4 = [??] [?]</td>
          <td>Initialization of input frame I1 from the method's
          descriptor,<br>
          B1 marked as "changed"</td>
        </tr>
        <tr>
          <td>1</td>
          <td>B3</td>
          <td></td>
          <td>I1= [I-] []<br>
          I2 = [??] [?]<br>
          <b>I3 = [IB] []</b><br>
          I4 = [??] [?]</td>
          <td>B1 marked as "unchanged",<br>
          merge of I1 and O1 into I3 (B3 is a successor of B1),<br>
          B3 marked as "changed"</td>
        </tr>
        <tr>
          <td>2</td>
          <td>B2, B4</td>
          <td></td>
          <td>I1= [I-] []<br>
          <b>I2 = [IB][]</b><br>
          I3 = [IB] []<br>
          <b>I4 = [IB] []</b></td>
          <td>B3 marked as "unchanged",<br>
          merge of I3 and O3 into I2 (B2 is a successor of B3),<br>
          B2 marked as changed,<br>
          merge of I3 and O3 into I4 (B4 is as successor of
          B3),<br>
          B4 marked as changed</td>
        </tr>
        <tr>
          <td>3</td>
          <td>B4, B3</td>
          <td></td>
          <td>I1= [I-] []<br>
          I2 = [IB] []<br>
          <b>I3 = [IA] []</b><br>
          I4 = [IB] []</td>
          <td>B2 marked as "unchanged",<br>
          merge of I2 and O2 into I3 (B3 is a successor of B2),<br>
          B3 marked as changed.</td>
        </tr>
        <tr>
          <td>4</td>
          <td>B3</td>
          <td></td>
          <td>I1= [I-] []<br>
          I2 = [IB] []<br>
          I3 = [IA] []<br>
          I4 = [IB] []</td>
          <td>B4 marked as "unchanged"</td>
        </tr>
        <tr>
          <td>5</td>
          <td>B2, B4</td>
          <td></td>
          <td>I1= [I-] []<br>
          <b>I2 = [IA] []</b><br>
          I3 = [IA] []<br>
          <b>I4 = [IA] []</b></td>
          <td>B3 marked as "unchanged",<br>
          merge of I3 and O3 into I2 (B2 is a successor of B3),<br>
          B2 marked as changed,<br>
          merge of I3 and O3 into I4 (B4 is as successor of
          B3),<br>
          B4 marked as changed</td>
        </tr>
        <tr>
          <td>6</td>
          <td>B4</td>
          <td></td>
          <td>I1= [I-] []<br>
          I2 = [IA] []<br>
          I3 = [IA] []<br>
          I4 = [IA] []</td>
          <td>B2 marked as "unchanged",<br>
          merge of I2 and O2 into I3 (B3 is a successor of B2),<br>
          B3 <b>not</b> marked as changed.</td>
        </tr>
        <tr>
          <td>7</td>
          <td></td>
          <td></td>
          <td>I1= [I-] []<br>
          I2 = [IA] []<br>
          I3 = [IA] []<br>
          I4 = [IA] []</td>
          <td>B4 marked as "unchanged"</td>
        </tr>
      </tbody>
    </table>
    <h4 id="uninitializedtypes">3.5.2 Uninitialized types</h4>
    <p>The simulation of a <code>NEW</code> <i>T</i> instruction
    results in a special <i>uninitialized</i> type being pushed on
    the stack. This special type contains the offset of the
    <code>NEW</code> instruction that created it. When an
    <code>INVOKESPECIAL</code> instruction for a <i>T</i>
    constructor is simulated, all occurrences of this special type
    in the current stack map frame must be replaced with the normal
    <i>T</i> type.</p>
    <p>The basic block input and output frame data structures
    presented in the previous section are not sufficient to take
    uninitialized types into account. Indeed, when a constructor
    invocation is visited, the type of the target may be unknown,
    and many local variable and operand stack types may also be
    unknown. It is therefore impossible to replace all occurrences
    of the target type everywhere in the stack map frame.</p>
    <p>For this reason an additional data structure is associated
    with each basic block, namely the list of types that are
    initialized in this basic block (these types can be relative to
    the unknown input stack map frame of the basic block). This
    data structure is constructed during the visit of instructions,
    and is used in <code>computeAllFrames</code>, when all the
    types are known.</p>
    <h4 id="exceptionhandlers">3.5.3 Exception handlers</h4>
    <p>For all the instructions covered by an exception handler,
    the control flow can jump to the exception handler block. This
    means that, inside the region covered by an exception handler,
    and as a consequence of the definition of basic blocks, basic
    blocks are reduced to individual instructions. In this case the
    advantage of using an algorithm working at the basic block
    level is lost, since there are as many basic blocks as
    instructions.</p>
    <p>Hopefully it is not necessary to really use one basic block
    per instruction inside regions covered by exception handlers.
    This is because not all the frames associated to these
    instructions have an impact on the input frame of the exception
    handler. Indeed this input frame only contains local variable
    types, and its stack is reduced to a single element that
    depends only on the type of exception caught by this handler.
    As a consequence only the frames associated with the
    instructions that affect local variables are important. In
    practice, this means that, inside regions covered by exception
    handlers, <i>x</i><code>STORE</code> instructions end the
    current basic block (and start a new one) like, for instance,
    an <code>IFEQ</code> instruction.</p>
    <p>As an example, consider the following method:</p>
    <pre>public m(Ljava/lang/Integer;Ljava/lang/Float;)Ljava/lang/Number;
  TRYCATCHBLOCK L0 L1 L1 java/lang/Exception
  ACONST_NULL
  ASTORE 3
 L0
  ALOAD 1
  ASTORE 3
  ALOAD 2
  ASTORE 3
  ALOAD 3
  ARETURN
 L1
  ASTORE 4
  ALOAD 3
  ARETURN
</pre>
    <p>Normally, due to the exception handler, each instruction
    between L0 and L1 should be a distinct basic block, which would
    give 6 basic blocks inside this region. In practice, thanks to
    the above optimization, only the <code>ASTORE</code>
    instructions change the current basic block, which gives 3
    basic blocks (<code>ALOAD 1 ASTORE 3</code>, <code>ALOAD 2
    ASTORE 3</code> and <code>ALOAD 3 ARETURN</code>). Note that if
    the instructions between L0 and L1 were considered as a single
    basic block, the frame computed for L1 would be incorrect: it
    would indeed be the same as the output frame of the previous
    block, where local variable 3 is of type <code>Float</code>
    (whereas the correct value is the common super type of
    <code>Integer</code> and <code>Float</code>, i.e.
    <code>Number</code>).</p>
    <p><b>Note:</b> the edges of the control flow graph that
    connect basic blocks to exception handler blocks are not
    constructed in the <code>visitTryCatchBlock</code> method but
    in the <code>computeAllFrames</code> method. Indeed, since the
    <code>visitTryCatchBlock</code> method must be called before
    the labels passed as arguments to this method are visited, it
    is not possible to know in this method which labels belong to
    the range protected by this handler.</p>
    <h4 id="deadcode">3.5.4 Dead code</h4>
    <p>The fix point algorithm used in the second step of the
    algorithm described in <a href="#fixpoint">section 3.5.1</a> is
    limited to reachable code. Indeed, by definition, reachable
    code is code that can be reached from the initial basic block
    in the control flow graph, and the fix point algorithm is
    precisely looking at these blocks. As a consequence the
    algorithm does not compute the input frame of dead basic
    blocks.</p>
    <p>Unfortunately the Java 6 split verifier requires a stack map
    frame for every basic block, even unreachable ones. The
    problem, as shown above, is that these frames are not computed
    and, even worse, <i>cannot</i> be computed. Indeed an
    unreachable basic block can contain illegal bytecode sequences,
    such as <code>ISTORE 1 ALOAD 1</code> (more precisely this
    <i>was</i> possible with the JVM verifier prior to Java 6; but
    this is no longer possible with the new verifier).</p>
    <p>The consequence of all this is that dead code must either be
    removed or replaced with a valid bytecode sequence whose stack
    map frame can be easily computed. The first solution was judged
    too complicated. So the second solution has been chosen.</p>
    <p>A simple solution is to replace dead code with
    <code>NOP</code> instructions. In this case any stack map frame
    will be ok for these blocks. The only problem is that execution
    can fall from the end of a dead code block to the end of the
    method or to the start of a reachable block. So either the
    stack map frame for the dead code block must be consistent with
    the frame of the next block, or the last instruction of the
    dead code block must not be replaced with a <code>NOP</code>
    but with an instruction without successor, such as
    <code>RETURN</code>, <code>GOTO</code>, or
    <code>ATHROW</code>.</p>
    <p>The first solution is too complicated; the second one is
    possible, but the fact that the dead code block can be reduced
    to a single byte must be taken into account: there is not
    always enough room to replace it with <code>NOP</code>
    instructions followed by a <code>GOTO</code>, for example.
    <code><i>x</i>RETURN</code> can be used (this is a single byte
    instruction), but this requires adjustments to the method's
    return type. The <code>ATHROW</code> instruction does not have
    this problem, and is also a single byte instruction. It was
    therefore chosen to end the dead code blocks.</p>
    <p>Note that it is not necessary to insert instructions to
    create something on stack before <code>ATHROW</code>: the stack
    map frame for this block can "declare" that, when the execution
    of this basic block begins, there is already an exception on
    stack (there will be no consistency problem with other frames
    since this block is unreachable. Also there is no problem with
    declared exceptions, because the verifier does not check that
    <code>ATHROW</code> instructions are consistent with declared
    exceptions).</p>
    <p>But declaring a stack map frame of the form []
    [java/lang/Throwable] for dead basic blocks may cause a problem
    if this block is in the range of an exception handler: the
    stack map frame for this handler may be inconsistent, with a
    non empty list of local variable types (the stack part will
    always be consistent since it always has the form [exception
    type] for an exception handler). To solve this, we remove the
    dead basic blocks from the exception handler ranges (which may
    remove a handler, decrease its range, or split its range in two
    sub ranges).</p>
    <p>In summary, the solution for dead code blocks is to replace
    these blocks with <code>NOP</code> ... <code>NOP</code>
    <code>ATHROW</code>, to declare a [] [java/lang/Throwable]
    stack map frame for these blocks, and to remove the dead code
    blocks from the exception handlers.</p>
    <h4 id="subroutines">3.5.5 Subroutines</h4>
    <p>The <code>JSR</code> and <code>RET</code> instructions, used
    for subroutines, complicate the control flow and data flow
    analysis algorithms. Hopefully they must not be used with Java
    6 classes, so they do not have any impact on the algorithm used
    to compute stack map frames. But they do complicate the
    algorithm used to compute the maximum stack size, with the
    <code>COMPUTE_MAXS</code> option. More precisely they do not
    impact the algorithm used to compute the maximum stack size
    from the control flow graph, but they complicate the
    construction of this graph. Like for exception handlers, the
    edges in the control flow graph that correspond to subroutines
    are computed in <code>computeMaxStackAndLocal</code>.</p>
    <p>The first step consists in finding, for each basic block, to
    which subroutine it "belongs". A basic block may be reached
    from several subroutines, but we say that it "belongs" to the
    "oldest" of these subroutines (with the convention that a
    subroutine calling another one is "older" than the callee). We
    compute the owner subroutine of each basic block as
    follows:</p>
    <ul>
      <li>visit all the basic blocks that are reachable from the
      first one, without following a <code>JSR</code> or
      <code>RET</code> instruction, and mark them as belonging to a
      main "subroutine". In the process, push all the targets of
      the visited JSR instructions into a queue Q.</li>
      <li>while the queue Q is not empty, pop a JSR target from it,
      visit all the basic blocks reachable from this JSR target
      (without following a <code>JSR</code> or <code>RET</code>
      instruction), and mark them as belonging to the same, new
      subroutine, <i>if they are not already marked as belonging to
      a previous subroutine</i>. In the process, push all the
      targets of the visited JSR instructions into Q.</li>
    </ul>
    <p>The second step consists in finding, for each
    <code>RET</code> instruction, to which possible basic blocks it
    can return to. The possible basic blocks are those that follow
    <code>JSR</code> instructions. We therefore examine each
    <code>JSR</code> instruction in turn. For each such
    <code>JSR</code> instruction <i>I</i> we look at the basic
    blocks that belong to the called subroutine. When a
    <code>RET</code> instruction is found we add the block
    following <i>I</i> as a successor of the <code>RET</code>
    instruction (except if <i>I</i> and the <code>RET</code>
    instruction belong to the same subroutine, which can happen if
    a subroutine returns to its parent subroutine without a
    <code>RET</code>).</p>
    <p>Let's take an example to illustrate this:</p>
    <pre>public m(Z)V
 L0
  JSR L2
 L1
  RETURN
 L2
  ASTORE 2
  JSR L4
 L3
  GOTO L5
 L4
  ASTORE 3
  ILOAD 1
  IFEQ L5
  RET 3
 L5
  RET 2
</pre>
    <p>After all the instructions have been visited in
    <code>MethodWriter</code>, and just before
    <code>computeMaxStackAndLocal</code> is called, the control
    flow graph is the following (L1 and L3 are not real successors
    of L0 and L2: these edges are only used to keep track of
    <code>JSR</code>'s return addresses, and are ignored during the
    control flow graph analysis used to compute the maximum stack
    size):</p>
    <ul>
      <li>L0 successors: L2, <i>L1</i></li>
      <li>L1 successors: <i>none</i></li>
      <li>L2 successors: L4, <i>L3</i></li>
      <li>L3 successors: L5</li>
      <li>L4 successors: L5</li>
      <li>L5 successors: <i>none</i></li>
    </ul>
    <p>As explained above, the first step in
    <code>computeMaxStackAndLocal</code> consists in finding, for
    each basic block, to which subroutine it belongs. The blocks
    that are reachable from L0 without following a <code>JSR</code>
    or a <code>RET</code> are L0 and L1: they are marked as
    belonging to subroutine #1, and the JSR target L2 is enqueued.
    L2 is then removed from the queue, and the blocks that are
    reachable in the same way from L2, namely L2, L3 and L5, are
    marked as belonging to subroutine #2. In the process the JSR
    target L4 is enqueued. Finally L4 is removed from the queue,
    and the blocks that are reachable in the same way from L4, and
    not already marked, are marked as belonging to subroutine #3.
    Here this means only L4 is marked, because L5 was already
    marked as belonging to subroutine #2 (this happened because the
    nested subroutine #3 can "return" to its parent subroutine #2
    without a <code>RET</code>):</p>
    <ul>
      <li>L0 belongs to: subroutine #1</li>
      <li>L1 belongs to: subroutine #1</li>
      <li>L2 belongs to: subroutine #2</li>
      <li>L3 belongs to: subroutine #2</li>
      <li>L4 belongs to: subroutine #3</li>
      <li>L5 belongs to: subroutine #2</li>
    </ul>
    <p>The second step consists in finding the successors of the
    <code>RET</code> instructions. As explained above, this is done
    by examining each <code>JSR</code> instruction in turn. The
    first one, in L0, leads to the analysis of the basic blocks
    that belong to subroutine #2. In these basic blocks we find
    only one <code>RET</code> instruction, in L5. These
    <code>JSR</code> and <code>RET</code> instructions do not
    belong to the same subroutine, so we add L1 (the next basic
    block after the <code>JSR</code> in L0) as a successor of L5.
    The second <code>JSR</code> instruction, in L2, leads to the
    analysis of the basic blocks of subroutine #3. In these basic
    blocks we find one <code>RET</code> instruction, in L4. L2 and
    L4 do not belong to the same subroutine, so we add L3 (the next
    basic block after the <code>JSR</code> in L2) as a successor of
    L4.</p>
    <p>The final control flow graph is the following:</p>
    <ul>
      <li>L0 successors: L2, <i class="grey">L1</i></li>
      <li>L1 successors: <i>none</i></li>
      <li>L2 successors: L4, <i class="grey">L3</i></li>
      <li>L3 successors: L5</li>
      <li>L4 successors: L5, <b>L3</b></li>
      <li>L5 successors: <b>L1</b></li>
    </ul>
    <p><b>Note:</b> you may have noticed that the L4 "basic block"
    is not a real basic block, because it contains several
    instructions that can lead to other blocks. In fact it is the
    union of two consecutive basic blocks. This is not an error:
    with the <code>COMPUTE_MAXS</code> option it is not always
    necessary to decompose the control flow graph down to
    individual basic blocks. Therefore, when possible, several
    consecutive basic blocks are represented as a single block, for
    optimization purposes.</p>
    <h2 id="optimizations">4 Code optimizations</h2>
    <p>The main objective of ASM is to get the smallest and fastest
    code as possible, while keeping a quite "clean" public API.
    This section explains the techniques used <i>in this
    project</i> to achieve these objectives (many of them are
    <i>not</i> recommended for mainstream development).</p>
    <h3 id="optimizeperformance">4.1 Optimizing performance</h3>
    <p>The first and most important step to get good performances
    is to use the right API and good algorithms [R0]. Sometimes it
    is hard to decide which API or algorithm is best without
    actually implementing and testing all options. In this case,
    take the time to implement and test all options to find the
    best one. There are however some general rules that can be used
    when designing an API and when implementing it, in order to get
    good performances (a side effect of these rules is to reduce
    code size):</p>
    <ul>
      <li>[R1] the API must stay very close to the internal class
      file structures, in order to avoid costly conversions during
      parsing and writing. Many examples of this rule can be seen
      in the existing API: internal class names, type descriptors
      and signatures are passed as argument in visit methods in the
      same form as they are stored in the class file. Stack map
      frames are also visited as they as stored in the class file,
      i.e. in a compressed form (although there is an option to
      uncompress them). The drawback of this rule is when several
      class adapters need a high level view of these encoded
      structures (for example a <code>SignatureVisitor</code> based
      view of a signature string): indeed, in this case, the
      decoding and encoding steps will be executed in each adapter,
      while they could be executed only once in
      <code>ClassReader</code> and <code>ClassWriter</code>.</li>
      <li>[R2] the implementation must not include any check or
      verification, at any level (class file parsing, preconditions
      of methods, validity of bytecode sequences, etc). These
      verifications must be added in
      <code>Check</code><i>Xxx</i><code>Adapter</code>
      classes.</li>
    </ul>
    <p>Once the best API and algorithms have been found, several
    "low level" techniques can be used to optimize
    performances:</p>
    <ul>
      <li>[R3] avoid string manipulation operations. These
      operations generally have a high cost. Examples of this can
      be seen in <code>ClassReader</code>: the
      <code>cpInfoValues</code> array is used to avoid parsing and
      building strings several times for the same constant pool
      UTF8 item. Another example is in the <code>Label</code>
      class: the types used for stack map frames are encoded as int
      values instead of strings (they were initially stored as
      strings; the change to int values improved performances a
      lot).</li>
      <li>[R4] avoid array copy operations. Several examples of
      this principle can be seen in the existing implementation.
      For example the <code>toByteArray</code> method first
      computes the size of the class, then allocates a
      <code>ByteVector</code> of this size, and finally writes the
      class content in this vector. This avoids many calls to the
      <code>enlarge</code> method in <code>ByteVector</code>, and
      therefore many array copy operations.</li>
      <li>[R5] avoid getter and setter methods, at least for non
      public or protected fields. Some JVMs do not inline these
      methods, in which case accessing fields directly is faster
      than using getter and setters. This also saves code. The core
      package does not use any such method. The tree package also
      exposes many fields directly.</li>
      <li>[R6] copy frequently accessed instance fields to local
      variables to reduce field access operations (this is the
      logical continuation of the previous technique). See for
      example the <code>ByteVector</code> class: the
      <code>length</code> and <code>data</code> fields are copied
      into local variables in methods that access them several
      times. A variant of this rule is to replace fields with
      method parameters (this variant was used in the
      <code>signature</code> package - see <a href=
      "#optimizeexample">section 4.3</a>).
      </li>
      <li>[R7] cache the result of complex functions in order to
      execute them only once. This rule is used, for example, in
      the <code>visitMethod</code> method in
      <code>MethodWriter</code>: the result of
      <code>getArgumentsAndReturnSizes</code> for a method
      <code>Symbol</code> is cached in a lazily computed field of
      <code>Symbol</code>. It is also used in
      <code>ClassReader</code>: the <code>cpInfoValues</code> array
      is used as a cache to avoid parsing the same string constant
      pool item several times.</li>
      <li>[R8] use <code>int</code> coded data structures in order
      to replace slow data structure access methods with fast
      arithmetic or bitwise operations (this also reduces code
      size). Several examples of this rule can be seen in the
      existing code: the boolean stack encoded as an
      <code>int</code> in <code>SignatureWriter</code>, the
      abstract types encoded as <code>int</code> in
      <code>Label</code>, etc.</li>
      <li>[R9] use <code>switch</code> statements that can be
      compiled into <code>TABLESWITCH</code> instead of
      <code>LOOKUPSWITCH</code> (the first opcode executes faster),
      where possible (this requires switch case constants that are
      not sparse).</li>
    </ul>
    <p>These techniques must be used with care (because they can
    make code harder to understand and to maintain) and only when
    they bring a real performance benefit. In order to see if it is
    the case, the performances of every proposed optimization must
    be compared to the performances of the current code (if
    possible on several JVMs, in order to exclude singularities due
    to specific JVM optimization strategies).</p>
    <p>Of course optimizations must be applied in priority to the
    code that is responsible for the most important part of the
    total execution time, in order to get the best performance
    improvements. In order to detect these "hotspots", a code
    profiler can be used. It is also possible to turn some code
    sections on or off, in order to measure, by difference to the
    normal case, the cost of this section.</p>
    <h3 id="optimizesize">4.2 Optimizing code size</h3>
    <p>The obvious way to reduce code size is to reduce the number
    of classes and methods! This begins by reducing the number of
    abstract classes in the public API (not because they are big,
    but because it indirectly reduces the number of classes and
    methods) [R10]. This reduction generally requires compromises
    with what a "clean" object oriented API would be. Whether these
    compromises are worthwhile or not must be decided on a case by
    case basis. Several such compromises can be detected in the
    current public ASM API. For example the
    <code>AnnotationVisitor</code> abstract class is used both for
    annotations and annotation arrays although, in the second case,
    the <code>name</code> argument is useless and would not have
    been used if an <code>AnnotationArrayVisitor</code> abstract
    class were defined. Another example is the
    <code>SignatureVisitor</code> abstract classs a single class is
    used to represent a quite complex recursive data structure
    that, in a "normal" object oriented design, would be
    represented with up to 8 abstract classes.</p>
    <p>The number of classes can be reduced in several ways. The
    most "elegant" one is to use appropriate design patterns [R11].
    For instance the <code>ClassReader</code> class needs
    <code>Attribute</code> factories in order to create attribute
    objects for the class, method and field attributes. But instead
    of using the Factory design pattern, which requires two
    classes, ASM uses the Prototype pattern, which uses only one
    class.</p>
    <p>The number of classes can also be reduced by merging several
    related classes into a single one [R12]. For instance a single
    <code>Symbol</code> class is used to represent all the constant
    pool item types, and the <code>Label</code> class is used to
    represent both bytecode offsets and basic blocks. The drawback
    of this approach is that it increases memory requirements (an
    integer <code>Symbol</code> object, for example, uses 7 fields
    while an <code>IntegerSymbol</code> class would require only 2
    fields) and object instantiation times (<code>Label</code> and
    <code>Frame</code> classes were initially merged but have been
    separated in order to improve performances).</p>
    <p>The number of methods can be reduced by inlining methods
    that are called at only one place in the code (a method that is
    called from several places can also be inlined if the client
    code can be refactored to call it at only one place) [R13].
    Another benefit of this technique is that it increases
    performances.</p>
    <h3 id="optimizeexample">4.3 An example</h3>
    <p>This section illustrates the previous optimization
    techniques on a real example, namely the
    <code>asm.signature</code> package. The goal of this package is
    to provide an event based API, a parser and a writer for the
    generics signature grammar, given below:</p>
    <div style=
    "width: 90%; padding: 8px; margin: 1em auto; background-color: #fafafa;">
      <i>ClassSignature</i>:<br>
      &nbsp;&nbsp;<i>FormalTypeParameters</i>?
      <i>ClassTypeSignature</i> <i>ClassTypeSignature</i>*<br>
      <br>
      <i>FormalTypeParameters</i>:<br>
      &nbsp;&nbsp;<span class="red">&lt;</span>
      <i>FormalTypeParameter</i>+ <span class="red">&gt;</span><br>
      <br>
      <i>FormalTypeParameter</i>:<br>
      &nbsp;&nbsp;<span class="red">Identifier</span>
      <i>FieldTypeSignature</i>? <i>FieldTypeSignature</i>*<br>
      <br>
      <i>FieldTypeSignature</i>:<br>
      &nbsp;&nbsp;<i>ClassTypeSignature</i> |
      <i>ArrayTypeSignature</i> | <i>TypeVariableSignature</i><br>
      <br>
      <i>ClassTypeSignature</i>:<br>
      &nbsp;&nbsp;<span class="red">L</span> <span class=
      "red">Identifier</span> ( <span class="red">/</span>
      <span class="red">Identifier</span> )* <i>TypeArguments</i>?
      ( <span class="red">.</span> <span class=
      "red">Identifier</span> <i>TypeArguments</i>? )* <span class=
      "red">;</span><br>
      <br>
      <i>TypeArguments</i>:<br>
      &nbsp;&nbsp;<span class="red">&lt;</span>
      <i>TypeArgument</i>+ <span class="red">&gt;</span><br>
      <br>
      <i>TypeArgument</i>:<br>
      &nbsp;&nbsp;<span class="red">*</span> | ( ( <span class=
      "red">+</span> | <span class="red">-</span> )?
      <i>FieldTypeSignature</i> )<br>
      <br>
      <i>ArrayTypeSignature</i>:<br>
      &nbsp;&nbsp;<span class="red">[</span>
      <i>TypeSignature</i><br>
      <br>
      <i>TypeVariableSignature</i>:<br>
      &nbsp;&nbsp;<span class="red">T</span> <span class=
      "red">Identifier</span> <span class="red">;</span><br>
      <br>
      <i>TypeSignature</i>:<br>
      &nbsp;&nbsp;<span class="red">Z</span> | <span class=
      "red">C</span> | <span class="red">B</span> | <span class=
      "red">S</span> | <span class="red">I</span> | <span class=
      "red">F</span> | <span class="red">J</span> | <span class=
      "red">D</span> | <i>FieldTypeSignature</i><br>
      <br>
      <i>MethodTypeSignature</i>:<br>
      &nbsp;&nbsp;<i>FormalTypeParameters</i>? <span class=
      "red">(</span> <i>TypeSignature</i>* <span class=
      "red">)</span> ( <i>TypeSignature</i> | <span class=
      "red">V</span> ) ( <span class=
      "red">^</span><i>ClassTypeSignature</i> | <span class=
      "red">^</span><i>TypeVariableSignature</i> )*<br>
    </div>
    <p>The first design of this package used 7 abstract classes,
    roughly corresponding to the grammar non terminals:</p>
    <ul>
      <li><code>ClassSignatureVisitor</code></li>
      <li><code>FormalTypeParameterVisitor</code></li>
      <li><code>FieldTypeSignatureVisitor</code></li>
      <li><code>ClassTypeSignatureVisitor</code></li>
      <li><code>TypeArgumentsVisitor</code></li>
      <li><code>TypeSignatureVisitor</code></li>
      <li><code>MethodTypeSignatureVisitor</code></li>
    </ul>
    <p>The parser was generated with <code>JavaCC</code> and the
    writer used 7 classes, one per abstract class.</p>
    <p>The second step was to replace the generated parser with a
    hand written, recursive descent parser, containing 11 recursive
    methods (one per rule of the grammar). This led to major
    performance improvements, and to a huge code size reduction.
    This was due to the fact that hand written code can be more
    efficient than generated code, and also to the fact that all
    lexical and syntactic verifications were removed ([R2]).</p>
    <p>In the third step a refactoring reduced the number of writer
    classes to 6 instead of 7 (by using inheritance).</p>
    <p>In the fourth step the number of abstract classes was
    reduced to 4 ([R10]), and the 6 writer classes were merged into
    a single one ([R12]), using a boolean stack encoded as an
    <code>int</code> ([R8]). The parser was mostly unchanged. The
    reduced API allowed invalid signatures to be generated (it
    corresponded to a generalized grammar where <i>FieldType</i>,
    <i>ClassType</i>, <i>ArrayType</i>, <i>TypeVariable</i> and
    <i>Type</i> are merged into a single <i>Type</i> non terminal),
    but this was seen as an acceptable compromise.</p>
    <p>In the sixth step the parser was optimized by replacing some
    fields that represented the last parsed character and its index
    with method arguments ([R6]). In addition some methods were
    inlined, which removed 6 parsing methods out of 11 ([R13]).</p>
    <p>Finally, after some feedback from users, the API was reduced
    to only one abstract class (although it allowed even more
    invalid signatures to be generated, this was judged more
    practical to define <code>SignatureAdapter</code>s), and this
    provided more opportunities to inline parser methods: the final
    parser contains only 3 parsing methods.</p>
    <p>The code size decreased from 22KB at the first step, to
    6.8KB at the second step, 4.5KB at the fourth step, and less
    than 4KB at the last step. At the same time the average time to
    parse and rebuild a signature decreased from 74 micro seconds
    at the first step, to 15 micro seconds at the second step, 5.4
    micro seconds at the fourth step, and less than 5 micro seconds
    at the last step.</p>
    <p>As can be seen from this example (more details can be found
    on the <a href=
    "https://mail.ow2.org/wws/arc/asm/2005-01/msg00041.html">ASM
    mailing list archives</a> of January 2005), improving
    performances often leads to code size reductions, and vice
    versa!</p>
  </div>
</body>
</html>
